{-# LANGUAGE
    MultiParamTypeClasses,
    RankNTypes,
    ScopedTypeVariables,
    FlexibleInstances,
    FlexibleContexts,
    UndecidableInstances,
    IncoherentInstances,
    PolyKinds #-}

class SKI r where
    app :: r (a -> b) -> r a -> r b
    s :: r ((a -> b -> c) -> (a -> b) -> a -> c)
    k :: r (a -> b -> a)
    i :: r (a -> a)

newtype Term a = Term { unTerm :: forall r. SKI r => r a }

instance SKI Term where
    app f x = Term $ app (unTerm f) (unTerm x)
    s = Term s
    k = Term k
    i = Term i

newtype ShowSKI x = ShowSKI { showSKI :: String }

instance SKI ShowSKI where
    app f x = ShowSKI $ "(" ++ showSKI f ++ " " ++ showSKI x ++ ")"
    s = ShowSKI "S"
    k = ShowSKI "K"
    i = ShowSKI "I"

newtype Next repr a b = Next { unNext :: repr (a -> b) }

instance SKI repr => SKI (Next repr a) where
    app f x = Next $ app (app s $ unNext f) $ unNext x
    s = Next $ app k s
    k = Next $ app k k
    i = Next $ app k i

lam :: SKI r =>
 (forall rn. SKI rn =>
  (forall t. r t -> rn t) -> rn a -> rn b) -> r (a -> b)
lam f = unNext $ f (Next . app k) (Next i)

c :: Term ((a -> b -> c) -> b -> a -> c)
c = lam (\withabc abc -> 
        lam (\withb b -> lam (\witha a ->
            app (app (witha $ withb abc) a) $ witha b)))

main :: IO ()
main = putStrLn $ showSKI $ unTerm c
